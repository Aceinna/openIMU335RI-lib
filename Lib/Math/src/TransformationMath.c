/*
 * File:   TransformationMath.cpp
 * Author: joemotyka
 *
 * Created on May 8, 2016, 12:35 AM
 */
#include <math.h>
#include "TransformationMath.h"
#include "Indices.h"

#ifdef INS_OFFLINE
#include <stdio.h>
#endif // INS_OFFLINE


/******************************************************************************
* @brief Calculate magnetic field in a perpendicular frame.
*        This perpendicular frame is generated by rotating the navigation frame about
*        its Z axis for YAW degree. The perpendicular frame is an intermediate frame
*        from the navigation frame to the body frame. Let v be a vector. v is described
*        in the navigation frame, the perpendicular frame and the body frame by v_n,
*        v_p and v_b, respectively. The following equation hold:
*          v_b = Rx(roll) * Ry(pitch) * Rz(yaw) * v_n
*          v_b = Rx(roll) * Ry(pitch) * v_p
*        In this routine, the gravity vector in the body frame and the magnetic vector
*        in the body frame are known, the magnetic vector in the perpendicular frame
*        need to be calculated.
*        note: accelerometer measurement = -gravity when there is no linear acceleration.
*        If acceleromter measurement is [0; 0; -1], the unit gravity vector should
*        be [0; 0; 1].
* @param magFieldVector      magnetic vector in the body frame.
* @param nedMagFieldVector   magnetic vector in the NED frame.
* @param unitGravityVector   unit gravity vector in the body frame.
******************************************************************************/
static void TransformMagFieldToPerpFrame(real magFieldVector[],
                                         real nedMagFieldVector[],
                                         real unitGravityVector[]);

//=============================================================================
/******************************************************************************
 * @brief Compute unit gravity vector in the body frame from accel measurement.
 *        Accelerometer measurement = -gravity when there is no linear acceleration.
 *        If acceleromter measurement is [0; 0; -1], the unit gravity vector should
 *        be [0; 0; 1].
 *
 * @param accel             [in]    Accelerometer measurement. [g] or [m/s^2].
 * @param unitGravityVector [out]   Unit gravity vector in the body frame.
 *  
 *****************************************************************************/
void UnitGravity(real accel[], real unitGravityVector[])
{
    real const accelMag = sqrtf( (accel[0]*accel[0]) + (accel[1]*accel[1]) + (accel[2]*accel[2]) );
    real const invAccelMag = 1.0F / accelMag;
    unitGravityVector[0] = -accel[0] * invAccelMag;
    unitGravityVector[1] = -accel[1] * invAccelMag;
    unitGravityVector[2] = -accel[2] * invAccelMag;
}

/******************************************************************************
 * @brief Compute pitch and roll angle from unit gravity vector in the body frame.
 *
 * @param unitGravityVector [in]    unit gravity vector in the body frame.
 * @param eulerAngles       [out]   Euler angles in order [roll pitch yaw].
 *                                  roll is put in eulerAngle[0],
 *                                  and pitch in eulerAngle[1].
 *  
 *****************************************************************************/
void UnitGravityToEulerAngles(real unitGravityVector[], real eulerAngles[])
{
    eulerAngles[ROLL]  = atan2f( unitGravityVector[Y_AXIS], unitGravityVector[Z_AXIS] );
    eulerAngles[PITCH] = -asinf( unitGravityVector[X_AXIS] );
}

/******************************************************************************
 * @brief Compute yaw angle from unit gravity vector and magnetic measurement.
 *        The unit gravity vector in the body frame is used to project the magnetic
 *        measurement onto a perpendicular frame. The projected x and y component
 *        of the magnetic measurement in this perpendicular frame are used to compute
 *        the yaw angle.
 *
 * @param unitGravityVector [in]    Unit gravity vector in the body frame.
 * @param magFieldVector    [in]    Magnetic vector in the body frame.
 * @return Yaw angle. [rad].
 *****************************************************************************/
real UnitGravityAndMagToYaw(real unitGravityVector[], real magFieldVector[])
{
    real nedMagFieldVector[3] = {0.0F};
    // Transform the magnetic field vector from the body-frame to the plane normal to the gravity vector
    TransformMagFieldToPerpFrame( magFieldVector, nedMagFieldVector, unitGravityVector );

    // The negative of the angle the vector makes with the unrotated (psi = 0)
    //   frame is the yaw-angle of the initial frame.
    return (real)( -atan2( nedMagFieldVector[Y_AXIS], nedMagFieldVector[X_AXIS] ) );
}

/******************************************************************************
 * @brief Compute yaw angle from pitch, roll and magnetic measurement.
 *        The pitch and roll angles are used to project the magneticmeasurement
 *        onto a perpendicular frame. The projected x and y component of the
 *        magnetic measurement in this perpendicular frame are used to compute
 *        the yaw angle.
 *
 * @param roll              [in]    Roll angle. [rad].
 * @param pitch             [in]    Pitch angle. [rad].
 * @param magFieldVector    [in]    Magnetic vector in the body frame.
 * @return Yaw angle. [rad].
 *****************************************************************************/
real RollPitchAndMagToYaw(real const roll, real const pitch, real magFieldVector[])
{
    real nedMagFieldVector[3] = {0.0F};
    
    real sinRoll;
    real cosRoll;
    real sinPitch;
    real cosPitch;
    real temp;

    sinRoll  = (real)(sin( roll ));
    cosRoll  = (real)(cos( roll ));
    sinPitch = (real)(sin( pitch ));
    cosPitch = (real)(cos( pitch ));

    temp = ( sinRoll * magFieldVector[Y_AXIS] ) + ( cosRoll * magFieldVector[Z_AXIS] );

    nedMagFieldVector[X_AXIS] =  ( cosPitch * magFieldVector[X_AXIS] ) + ( sinPitch * temp );
    nedMagFieldVector[Y_AXIS] =  ( cosRoll  * magFieldVector[Y_AXIS] ) - ( sinRoll  * magFieldVector[Z_AXIS] );
    //nedMagFieldVector[Z_AXIS] = -sinPitch * magFieldVector[X_AXIS] + cosPitch * temp;

    return (real)( -atan2( nedMagFieldVector[Y_AXIS], nedMagFieldVector[X_AXIS] ) );
}

/******************************************************************************
* @brief Calculate magnetic field in a perpendicular frame.
*        This perpendicular frame is generated by rotating the navigation frame about
*        its Z axis for YAW degree. The perpendicular frame is an intermediate frame
*        from the navigation frame to the body frame. Let v be a vector. v is described
*        in the navigation frame, the perpendicular frame and the body frame by v_n,
*        v_p and v_b, respectively. The following equation hold:
*          v_b = Rx(roll) * Ry(pitch) * Rz(yaw) * v_n
*          v_b = Rx(roll) * Ry(pitch) * v_p
*        In this routine, the gravity vector in the body frame and the magnetic vector
*        in the body frame are known, the magnetic vector in the perpendicular frame
*        need to be calculated.
*        note: accelerometer measurement = -gravity when there is no linear acceleration.
*        If acceleromter measurement is [0; 0; -1], the unit gravity vector should
*        be [0; 0; 1].
* @param magFieldVector      magnetic vector in the body frame.
* @param nedMagFieldVector   magnetic vector in the NED frame.
* @param unitGravityVector   unit gravity vector in the body frame.
******************************************************************************/
static void TransformMagFieldToPerpFrame( real magFieldVector[],
                                          real nedMagFieldVector[],
                                          real unitGravityVector[] )
{
    real sinPitch;
    sinPitch = -unitGravityVector[0];
    if ( sinPitch >= 1.0 )          // roll and yaw undefined, assume roll = 0
    {
        nedMagFieldVector[0] = magFieldVector[2];
        nedMagFieldVector[1] = magFieldVector[1];
        nedMagFieldVector[2] = -magFieldVector[0];
        // set up some kind of flag to return
    }
    else if ( sinPitch <= -1.0F )    // roll and yaw undefined, assume roll = 0
    {
        nedMagFieldVector[0] = -magFieldVector[2];
        nedMagFieldVector[1] = magFieldVector[1];
        nedMagFieldVector[2] = magFieldVector[0];
        // set up some kind of flag to return
    }
    else
    {
        real sinRoll;
        real cosRoll;
        real cosPitch;
        real temp;
        cosPitch = sqrtf( 1.0F - (sinPitch*sinPitch) );   // pitch is (-90, 90), cos(pitch)>0
        sinRoll  = unitGravityVector[1] / cosPitch;
        cosRoll  = unitGravityVector[2] / cosPitch;
        temp = (sinRoll * magFieldVector[1]) + (cosRoll * magFieldVector[2]);
        nedMagFieldVector[0] = ( cosPitch * magFieldVector[0] ) + ( sinPitch * temp );
        nedMagFieldVector[1] = ( cosRoll  * magFieldVector[1] ) - ( sinRoll  * magFieldVector[2] );
        nedMagFieldVector[2] = ( -sinPitch * magFieldVector[2] ) + ( cosPitch * temp );
    }
}

/******************************************************************************
 * @brief Calculate NED relative position of two ECEF positions.
 *
 * @param rECEF_Init    [in]    Initial ECEF position. [m]
 * @param rECEF         [in]    Current ECEF position. [m].
 * @param R_NinE        [in]    Rotation matrix from NED to ECEF
 * @param dr_N          [out]   Current position w.r.t the initial position in
 *                              NED. [m]
 *  
 *****************************************************************************/
void ECEF_To_Base(float64_t rECEF_Init[], float64_t rECEF[],
                  real R_NinE[3][3], real dr_N[])
{
    real dr_E[NUM_AXIS];

    dr_E[X_AXIS] = (real)( rECEF[X_AXIS] - rECEF_Init[X_AXIS] );
    dr_E[Y_AXIS] = (real)( rECEF[Y_AXIS] - rECEF_Init[Y_AXIS] );
    dr_E[Z_AXIS] = (real)( rECEF[Z_AXIS] - rECEF_Init[Z_AXIS] );

    /* Convert from delta-position in the ECEF-frame to the NED-frame (the transpose
     * in the equations that followed is handled in the formulation)
     *
     *       N E          ( E N )T
     * dr_N = R  * dr_E = (  R  )  * dr_E
     *                    (     )
     */
    dr_N[X_AXIS] = (R_NinE[X_AXIS][X_AXIS] * dr_E[X_AXIS]) +
                   (R_NinE[Y_AXIS][X_AXIS] * dr_E[Y_AXIS]) +
                   (R_NinE[Z_AXIS][X_AXIS] * dr_E[Z_AXIS]);
    dr_N[Z_AXIS] = (R_NinE[X_AXIS][Z_AXIS] * dr_E[X_AXIS]) +
                   (R_NinE[Y_AXIS][Z_AXIS] * dr_E[Y_AXIS]) +
                   (R_NinE[Z_AXIS][Z_AXIS] * dr_E[Z_AXIS]);
    dr_N[Y_AXIS] = (R_NinE[X_AXIS][Y_AXIS] * dr_E[X_AXIS]) +
                   (R_NinE[Y_AXIS][Y_AXIS] * dr_E[Y_AXIS]) +
                   (R_NinE[Z_AXIS][Y_AXIS] * dr_E[Z_AXIS]);
}

/******************************************************************************
 * @brief Given an inital ECEF position and an position relative to the initial
 *        poistion in NED, convert the relative poistion to ECEF position.
 *        rECEF = rECEC_Init + (NED_to_ECEF) * rNED.
 *
 * @param r_N           [in]    Relative position in NED. [m]
 * @param rECEF_Init    [in]    "Absolute" position in ECEF. [m].
 * @param R_NinE        [in]    Rotation matrix from NED to ECEF.
 * @param rECEF         [out]   r_N plus rECEV_Init in ECEF. [m]
 *  
 *****************************************************************************/
void PosNED_To_PosECEF( real r_N[],
                        float64_t rECEF_Init[], //BaseECEF,
                        real R_NinE[3][3],
                        float64_t rECEF[])
{
    // ECEF = Base + delta
    real temp;
    temp = ( R_NinE[0][0] * r_N[X_AXIS] ) +
           ( R_NinE[0][1] * r_N[Y_AXIS] ) +
           ( R_NinE[0][2] * r_N[Z_AXIS] );
    rECEF[0] = rECEF_Init[0] + (float64_t)temp; // X

    temp = ( R_NinE[1][0] * r_N[X_AXIS] ) +
           ( R_NinE[1][1] * r_N[Y_AXIS] ) +
           ( R_NinE[1][2] * r_N[Z_AXIS] );
    rECEF[1] = rECEF_Init[1] + (float64_t)temp; // Y

    temp = ( R_NinE[2][0] * r_N[X_AXIS] ) +
           ( R_NinE[2][1] * r_N[Y_AXIS] ) +
           ( R_NinE[2][2] * r_N[Z_AXIS] );
    rECEF[2] = rECEF_Init[2] + (float64_t)temp; // Z
}

/******************************************************************************
 * @brief Convert ECEF position to [latitude, longitude, altitude].
 *
 * @param llaDeg   [out]   [latitude, longitude, altitude] in [deg, deg, m].
 * @param ecef_m    [in]    ECEF position. [m].
 *  
 *****************************************************************************/
void ECEF_To_LLA(float64_t llaDeg[], float64_t ecef_m[])
{
    float64_t P;
    float64_t theta;
    float64_t sinLat;
    float64_t sinTheta;
    float64_t cosTheta;
    float64_t Lat;

    P = sqrt( ( ecef_m[X_AXIS] * ecef_m[X_AXIS] ) + ( ecef_m[Y_AXIS] * ecef_m[Y_AXIS] ) );

    theta = atan2(ecef_m[Z_AXIS] * E_MAJOR_OVER_MINOR, P);

    sinTheta = sin(theta);
    cosTheta = cos(theta);

    Lat = atan2( (ecef_m[Z_AXIS] + ( EP_SQ * sinTheta * sinTheta * sinTheta )),
                (P - ( E_ECC_SQxE_MAJOR * cosTheta * cosTheta * cosTheta )) );
    llaDeg[LAT] = Lat * RAD_TO_DEG;
    llaDeg[LON] = atan2(ecef_m[Y_AXIS], ecef_m[X_AXIS]) * RAD_TO_DEG; // arctan(Y/X)

    sinLat = sin(Lat);
    llaDeg[ALT] = ( P / cos(Lat) ) - ( E_MAJOR / sqrt(1.0 - ( E_ECC_SQ * sinLat * sinLat )) ); // alt
}

#ifdef INS_OFFLINE
void printMtx(const float32_t* const a, int32_t const m, int32_t const n)
{
    int32_t i;
    int32_t j;
    for (i = 0; i < m; i++)
    {
        for (j = 0; j < n - 1; j++)
        {
            printf("%.9g, ", a[i * n + j]);
        }
        printf("%.9g\n", a[i * n + j]);
    }
}

void printVec(const float32_t* const v, int32_t const n)
{
    int32_t i;
    for (i = 0; i < n - 1; i++)
    {
        printf("%.9g, ", v[i]);
    }
    printf("%.9g\n", v[i]);
}
#endif // INS_OFFLINE

/******************************************************************************
 * @brief Limit angle error to be [-180, 180]deg.
 *
 * @param aErr  [in]    Angle. [deg].
 * @return aErr within [-180, 180]deg.
 *****************************************************************************/
real AngleErrDeg(real aErr)
{
    if ( (aErr < -360.0) || (aErr > 360.0) )
    {
        aErr = (real)fmod((float64_t)aErr, 360.0);
    }

    if (aErr > 180.0)
    {
        aErr -= (real)360.0;
    }
    else if (aErr < -180.0)
    {
        aErr += (real)360.0;
    }
    else
    {
        // do nothing
    }

    return aErr;
}

/******************************************************************************
 * @brief Limit angle error to be [-PI, PI].
 *
 * @param aErr  [in]    Angle. [rad].
 * @return aErr within [-2*PI, 2*PI].
 *****************************************************************************/
real AngleErrRad(real aErr)
{
    if ( (aErr < -TWO_PI) || (aErr > TWO_PI) )
    {
        aErr = (real)fmod((float64_t)aErr, TWO_PI);
    }
    
    if (aErr > PI)
    {
        aErr -= (real)TWO_PI;
    }
    else if (aErr < -PI)
    {
        aErr += (real)TWO_PI;
    }
    else
    {
        // do nothing
    }

    return aErr;
}
